# Базовые операции с Git

1. Создание локальной копии *главного репозитория*. Для начала нужно перейти в каталог, в котором вы хотите, чтобы появился каталог репозитория, и запустить в
нем терминал. Для пользователей **Linux** либо **MacOS**: запустить терминал и с помощью команды `cd` перейти в нужный каталог. Для пользователей **Windows**: перейти в проводнике в нужный каталог, щелкнуть правой кнопкой мыши в окне каталога и в контекстном меню выбрать пункт **"Git Bash"**. 
После запуска в терминале набрать команду: 
> `git clone https://github.com/вашеИмя/вашРепозиторий`

В результате в текущем каталоге будет создан подкаталог *вашРепозиторий*, содержащий копию главного репозитория. Для работы с репозиторием необходимо перейти в его каталог командой `cd` *'вашРепозиторий'*. 

---

2. Добавление новых файлов в репозиторий. Давайте создадим в каталоге          
репозитория test текстовый файлfirst.txt, содержащий строку текста "Some text". Однако то, что файл появился в каталоге репозитория не означает, что git его уже отслеживает ­ нужно указать это явно командой git add first.txt теперь наш файл находится под наблюдением git. Давайте сохраним изменения в репозитории и сделаем первый коммит: 
> `git commit ­m "My first commit"` 

Ключ ­m позволяет задать описание коммита. Описание обязательно, иначе коммит не будет выполнен. Теперь давайте создадим каталог dir, а в нем два текстовых файлa a.txt и b.txt. Чтобы при добавлении в git не перечислять их по отдельности, воспользуемся командой 
>`git add .` 

---

3. Сохранение изменений файлов . Добавим в файл first.txt еще одну строчку "Some more text" (не забудьте сохранить файл!). И снова закоммитим изменения. Однако если мы воспользуемся известной нам командой `git commit ­-m "more text added to first.txt"` то мы получим сообщение, что коммитить в общем­то нечего. Почему? Дело в том, что *git* опять же не знает, какие именно из измененных файлов мы хотим сохранить. Чтобы указать это явно, необходимо воспользоваться описанной выше командой `git add`. В то же время самый частый сценарий ­ сохранить изменения во всех файлах. Для этих целей в команде `git commit` есть ключик `­a`. Итого наша команда будет такой: `git commit -­a -­m "more text added to first.txt"` Чтобы меньше запоминать, вам будет достаточно для всех коммитов пользоваться командой именно такого вида. Однако помните, что ключ ­a позволяет учесть изменения только в файлах, уже находящихся под наблюдением *git*. А новые файлы перед коммитом необходимо предварительно явно добавить командой `git add` (про нее вам рассказали не просто так).

---

4. Отправка изменений в главный **репозиторий**. К этому моменту мы уже немало
сделали в нашей локальной копии репозитория, однако если вы обновите веб­страничку с главным репозиторием, вы увидите, что в нем никаких изменений нет. Как их туда внести? Для этого используется команда `git push`. В процессе выполнения команды от вас потребуется ввести ваш и логин и пароль от аккаунта на **GitHub**. Когда после успешного завершения команды мы обновим страничку с главным репозиторием, мы увидим, что теперь его содержимое совпадает с нашим локальным репозиторием.

----

5. Получение изменений из **главного репозитория**. Смоделируем ситуацию, в
которой нам это пригодится. Для этого откроем еще один *терминал* в каталоге, отличном от того, в котором лежит наш локальный репозиторий . И создадим еще одну локальную копию главного репозитория (как ­ описано вы ше). Итого у нас теперь есть два локальных репозитория: *первый* (старый) и *второй* (только что созданный). Представим, что второй репозиторий на самом деле находится на другом компьютере и с ним работает второй участник. И он решает внести какие-­то изменения в файл *first.txt* (например, добавим туда еще одну строчку текста), находящийся в его локальной копии, т.е. во втором репозитории. Сохраняем файл и коммитим: `git commit ­a ­m "more changes in first.txt"` и отправляем изменения на сервер: `git push`. Сейчас у нас синхронизированы главный и второй локальный **репозитории**, но первый локальный отстает. Ему нужно получить изменения из главного репозитория командой `git pull`. Ура, теперь у нас везде одинаковые версии.

---

6. Разрешение конфликтов. В заключение рассмотрим еще один частый сценарий,
распространенный при одновременной работе нескольких человек. Давайте в нашем первом локальном репозитории внесем еще какие-­нибудь изменения в файл *first.txt*, закоммитим и отправим их в главный репозиторий. А затем во втором локальном репозитории создадим файл *second.txt* и тоже закоммитим. Однако если теперь из второго репозитория мы попробуем сделать `git push`, то получим ошибку из-­за конфликта изменений. Почему? Для простоты можно считать, что при отправке изменений в локальном репозитории должна быть версия, основанная на версии главного репозитория. Тогда как мы во втором репозит ории пока ничего не знаем про последний коммит *first.txt*. Что делать? Сначала нам нужно получить изменения из главного репозитория, затем объединить их с нашими изменениями, и то, что получилось, отправить на **главный репозиторий**. Звучит непросто, но на самом деле первые два шага сама умеет делать команда `git pull`. Она достаточно умна, чтобы понять, что в нашем случае надо обновить файл *first.txt* и добавить *second.txt*. После чего нам остается просто отправить изменения командой `git push`. Итого получаем, что при отправке изменений безопасно пользоваться двумя последовательными командами: `git pull` (проверить на наличие новых изменений в репозитории и, если они есть, выкачать их и объединить с локальными изменениями) `git push` (отправить изменения в репозиторий).

---

Предыдущая страница - [GitBub.Репозиторий](repo4.md)

Главная страница - [Домой](Glavnyy.md)
